---
title: ''
author: ''
date: ''
output: 
  html_document:
    df_print: paged
    keep_md: true
  word_document:
    reference_docx: style.1.docx
---

```{r setup, include = FALSE}

  knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, 
                        fig.width  = 6 * 1.67, fig.height = 6)

  load("data/data.RData")

  library(descr)
  library(tidyverse)
  library(viridis)
  library(flextable)
  
```


TLDR: There are hip patients who are known carriers but not necessarily infected with a multi-drug resistant organism (MDRO). In order to prevent other patients from being colonised/cross contaminated by such organisms “MDRO patients” are isolated within the hospital. This really limits this cohort of patients’ access to basic care. Anecdotally they wait for much longer to get a bed on the ward and are left on trollies in ED far longer and also have to wait much longer to get to theatre for their broken hip…..but nobody has shown this.

Primary outcomes: Time to theatre for hip fracture Fixation, Time to ward bed from emergency department

Secondary outcomes: Thirty day mortality, local cost analysis (we have more detailed data for waterford)

Key variables in the dataset:

**adm_trauma_date_time**: Date & Time of Trauma causing Hip Fracture

**adm_date**: admission date

**adm_ae_dis_date_time**: Date and time of leaving ED for operating hospital *(key data piece for this study as often MDROs patients are stuck in EDs waiting for isolation beds)*

**adm_first_pres_hosp_date_time**: Date and time of arrival at first presenting hospital (not all hospitals have orthopaedics  e.g. if a patient presents to Kilkenny hospital and is subsequently transferred to Waterford for fixation -this time represents date/time of presentation to Kilkenny hospital)

**adm_ae_date_time**: Date and time of arrival to operating (orthopaedic) hospital
 
**adm_trauma_team_date_time**: Date & time seen by orthopaedic team in operating hospital
 
**adm_orth_ward_date_time**: Date & time admission to an orthopaedic ward *(Again a key piece of data here as often MDRO patients are delayed getting to ortho wards)*
 
**adm_primary_surgery_date_time**: Date & Time of primary surgery for hip fracture *this is one of our key outcomes (our hypothesis is that this is delayed in MDRO patients)*
 
**dis_date**: discharge date

**adm_ger_acute_assess_date_time**: Date & Time of assessment by geriatrician during acute admission
 
 
# Missing data for time variables

We need to establish how accurate the relevant dates are, so that we can feel confident they accurately reflect the relevant time variables we want to create. So the first step is just to try and look at them. 

Here are the missing values for each time variable.  

```{r}

  target_times <- c(
   "adm_trauma_date_time", "adm_ae_dis_date_time", 
   "adm_first_pres_hosp_date_time", "adm_ae_date_time", "adm_date", 
   "adm_trauma_team_date_time", "adm_orth_ward_date_time", 
   "adm_primary_surgery_date_time", "dis_date"
  )

  missing <- data_frame(
    var = target_times, 
    not_missing = unlist(
      map(data[target_times], function(x)table(!is.na(x))["TRUE"])
      )
    ) %>%
    mutate(missing_pct = round(1 - (not_missing/18118), 3) * 100, 
           var = reorder(var, missing_pct))
  
  ggplot(missing, aes(x = var, y = missing_pct, fill = missing_pct)) +
    geom_bar(stat = "identity") +
    xlab("") +
    ylab("Percent Missing") +
    coord_flip() +
    scale_fill_viridis(guide = FALSE, end = 0.4)

  
```

Below we relate each of these event times to the admission date/time (with no missing values), finding that several of them are likely to fall both before (in some patients) and after (in others) the admission time. 

```{r}

  timing <- data_frame()
  for(i in target_times){
    
    n1 <- nrow(filter(data, get(i) < adm_date)) 
    n2 <- nrow(filter(data, get(i) > adm_date)) 
    n3 <- nrow(filter(data, get(i) == adm_date)) 
    
    timing <- bind_rows(
      data_frame(
        var = i, 
        timing =  c(rep("< adm_date", n1), 
                    rep("> adm_date", n2), 
                    rep("= adm_date", n3))
      ),
      timing
    )
  }

  ggplot(timing, aes(x = var, fill = timing)) +
    geom_bar(position = "fill") +
    scale_fill_viridis(discrete = TRUE, end = 0.7) +
    ylab("Proportion of times") +
    xlab("") +
    coord_flip()
  

```

Repeat the same thing for discharge times. 

```{r}

  timing <- data_frame()
  for(i in target_times){
    
    n1 <- nrow(filter(data, get(i) < dis_date)) 
    n2 <- nrow(filter(data, get(i) > dis_date)) 
    n3 <- nrow(filter(data, get(i) == dis_date)) 
    
    timing <- bind_rows(
      data_frame(
        var = i, 
        timing =  c(rep("< dis_date", n1), 
                    rep("> dis_date", n2), 
                    rep("= dis_date", n3))
      ),
      timing
    )
  }

  ggplot(timing, aes(x = var, fill = timing)) +
    geom_bar(position = "fill") +
    scale_fill_viridis(discrete = TRUE, end = 0.7) +
    ylab("Proportion of times") +
    xlab("") +
    coord_flip() 
  

```

Based on these, I'd probably just stop condsidering *adm_ae_date_time*, *adm_trauma_date_time*, and *adm_first_pres_hosp_date_time* (unless there is some way to explain these findings). Just as a reminder, these were:

**adm_trauma_date_time**: Date & Time of Trauma causing Hip Fracture

**adm_ae_date_time**: Date and time of arrival to operating (orthopaedic) hospital

**adm_first_pres_hosp_date_time**: Date and time of arrival at first presenting hospital (not all hospitals have orthopaedics  e.g. if a patient presents to Kilkenny hospital and is subsequently transferred to Waterford for fixation -this time represents date/time of presentation to Kilkenny hospital)

And then we will also remove *adm_trauma_team_date_time* since so many are missing. 
 
Now we can look at what order these different events tend to come in. In the plot below, each little point is a person, showing the order that a given event appeared. For example, for most, but not all, the *adm_date* was the first, the *adm_ae_dis_date_time* second, *adm_orth_ward_date_time* third, *adm_primary_surgery_date_time* fourth, and the *dis_date* 5th (of all the patients, only 6 had all 6 of these dates, so you can't see them on the plot).
```{r}

# Remove these tricky times identified above
  target_times_2 <- c(
     "adm_ae_dis_date_time", "adm_date", "adm_orth_ward_date_time",
     "adm_primary_surgery_date_time", "dis_date"
    )

  long_times <- select(data, id, target_times_2) %>%
    gather(event, date, -id) %>%
    arrange(id, date) %>%
    group_by(id) %>%
    mutate(order = row_number()) %>%
    filter(!is.na(date)) %>%
    ungroup() %>%
    group_by(event) %>%
    mutate(mean_order = mean(order)) %>%
    ungroup() %>%
    mutate(event = reorder(event, mean_order))

  
```

```{r}

  ggplot(long_times, aes(x = order, y = event, color = event)) +
    geom_jitter(size = 0.1, alpha = 0.2) +
    scale_color_viridis(guide = FALSE, discrete = TRUE) +
    scale_x_continuous(breaks = 1:9) +
    theme_minimal() +
    theme(panel.grid = element_blank())

```

Here are the same data as a filled (proportional) bar chart. 

```{r}

  ggplot(long_times, aes(x = event, fill = factor(order))) +
    geom_bar(position = position_fill(reverse = TRUE)) +
    scale_fill_viridis("Order", discrete = TRUE) +
    coord_flip() +
    theme(panel.grid = element_blank())

```
Importantly, the plots above include people that don't have all 5 of these event times in their record. So here is what it looks like if we restrict the data to those with all 5 events. 

```{r}

  ids <- unique(filter(long_times, order == 5)$id)
  long_times_2 <- filter(long_times, id %in% ids)

```

```{r}
  ggplot(long_times_2, aes(x = order, y = event, color = event)) +
    geom_jitter(size = 0.1, alpha = 0.2) +
    scale_color_viridis(guide = FALSE, discrete = TRUE) +
    scale_x_continuous(breaks = 1:9) +
    theme_minimal() +
    theme(panel.grid = element_blank())
```

```{r}

  ggplot(long_times_2, aes(x = event, fill = factor(order))) +
    geom_bar(position = position_fill(reverse = TRUE)) +
    scale_fill_viridis("Order", discrete = TRUE) +
    coord_flip() +
    theme(panel.grid = element_blank())

```

This reduced dataset includes `r length(unique(long_times_2$id))` of `r nrow(data)` patients (`r round(length(unique(long_times_2$id))/ nrow(data), 3) * 100`%). 


# Time to AE

```{r}
  # target_times <- c(
  #  "adm_ae_dis_date_time", "adm_ae_date_time", "adm_date"
  # )
  # 
  # # map(data[target_times], function(x)table(is.na(x)))
  # # table(unlist(map(data[target_times], class)))
  # 
  # ae_times <- select(data, id, target_times) %>%
  #   filter(complete.cases(.)) %>%
  #   gather(event, date, -id) %>%
  #   arrange(id, date) %>%
  #   group_by(id) %>%
  #   mutate(order = row_number()) %>%
  #   ungroup() %>%
  #   group_by(event) %>%
  #   mutate(mean_order = mean(order)) %>%
  #   ungroup() %>%
  #   mutate(event = reorder(event, mean_order))
  # 
  # ggplot(ae_times, aes(x = order, y = event, color = event)) +
  #   geom_jitter(alpha = 0.1) +
  #   scale_color_viridis(guide = FALSE, discrete = TRUE) +
  #   scale_x_continuous(breaks = 1:9) +
  #   theme(panel.grid = element_blank())
  # 
  # length(unique(ae_times$id))

  
```
  
```{r}

  # ggplot(ae_times, aes(x = event, fill = factor(order))) +
  #   geom_bar(position = position_stack(reverse = TRUE)) +
  #   scale_fill_viridis("Order", discrete = TRUE) +
  #   coord_flip() +
  #   theme(panel.grid = element_blank())

```

```{r}

  # ggplot(data, aes(x = adm_leave_ae_diff, fill = mdro)) +
  #   geom_density() +
  #   facet_wrap(~mdro + anticoag)
  # 
  # select(data, adm_leave_ae_diff) %>% 
  #   arrange(adm_leave_ae_diff) %>%
  #   slice(1:50) %>%
  #   View()
  # 
  # class(data$adm_leave_ae_diff)

```


# Time to theatre for hip fracture fixation

```{r}

# There is already a time to surgery variable. Does it match if I try to
# calcuate from the dates?

  # ggplot(data, aes(x = time_to_surg, y = adm_to_surg, 
  #                  color = as.Date(as.character(adm_date)))) +
  #   geom_point(size = 2, alpha = 0.5) +
  #   scale_color_viridis("Admit date", 
  #                       begin = 0.2, option = "inferno", trans = "date") +
  #     theme(panel.background = element_rect(fill = "grey20"),
  #           panel.grid = element_blank(),
  #           strip.background = element_rect(fill = "grey20"),
  #           strip.text = element_text(color = "white")) 
  # 
```

```{r}

# There is already a time to orth variable. Does it match if I try to
# calcuate from the dates?

  # ggplot(data, aes(x = time_to_ortho, y = adm_to_orth, 
  #                  color = as.Date(as.character(adm_date)))) +
  #   geom_point(size = 2, alpha = 0.5) +
  #   scale_color_viridis("Admit date", 
  #                       begin = 0.2, option = "inferno", trans = "date") +
  #     theme(panel.background = element_rect(fill = "grey20"),
  #           panel.grid = element_blank(),
  #           strip.background = element_rect(fill = "grey20"),
  #           strip.text = element_text(color = "white")) 
  
```


```{r}
# Time to theatre
  
  # select(data, id, hosp, mdro, anticoag, adm_to_surg, time_to_surg, adm_date, 
  #        adm_primary_surgery_date_time) %>%
  # filter(hosp == "0600") %>%
  # head() %>%
  # mutate(id = reorder(id, time_to_surg)) %>%
  # gather(type, date, adm_date, adm_primary_surgery_date_time) %>%
  # ggplot(aes(x = date, y = id, shape = type, group = id, color = time_to_surg)) +
  #   geom_point(size = 3) +
  #   geom_line() +
  #   scale_color_viridis()

```




```{r publication_qualityplots}

  ggsave("XXX", device = "pdf", dpi = 600)

```

```{r if_html, eval = knitr::opts_knit$get("rmarkdown.pandoc.to") == "html"}

# use flextable (works for MD files on github too)

```

```{r if_word, eval = !knitr::opts_knit$get("rmarkdown.pandoc.to") == "html"}

# use kable

```

```{r code_book}

  print(summarytools::dfSummary(data), method = "render")

```

```{r sysinfo}

  DescTools::SysInfo()

```



